
# Взаимодействие с вебхуками и базой данных Supabase

Этот документ описывает, как веб-приложение взаимодействует с базой данных Supabase и обрабатывает входящие вебхуки для создания и управления кейсами.

## Взаимодействие с базой данных Supabase

Приложение использует Supabase в качестве бэкенда, взаимодействуя с ним через PostgREST API и вызывая хранимые процедуры (RPC). Основная логика работы с данными инкапсулирована в виде RPC-функций, которые вызываются из клиентского кода через обертку в `src/lib/rpc.ts`.

### Чтение данных

#### Получение кейсов в работе (`working`)

- **Источник:** `src/app/cases/working/page.tsx`
- **Описание:** При загрузке страницы, компонент выполняет прямой запрос к таблице `checkcases` для получения списка кейсов, находящихся в работе. Это один из немногих случаев, где используется прямой доступ к таблице, а не RPC.
- **Supabase JS Client:**
  ```javascript
  const { data, error } = await supabase.from('checkcases').select('id, content');
  ```

#### Получение необработанных кейсов (`unprocessed`)

- **Источник:** `src/components/RecordsApp.tsx`
- **Описание:** Этот компонент вызывает RPC-функцию `get_telegrambad_backup_page_pairs` для получения пагинированного списка записей с возможностью фильтрации и поиска.
- **RPC-функция:** `get_telegrambad_backup_page_pairs`
- **Параметры:** `p_search`, `p_archived`, `p_with_dupes_only`, `p_limit`, `p_offset`, `p_pairs_thr`.

#### Получение данных для модального окна

- **Источник:** `src/components/RecordModal.tsx`
- **Описание:** При открытии записи в модальном окне, параллельно запрашиваются данные о самой записи и о похожих на нее.
- **RPC-функции:**
    - `get_record_cluster_backup({ p_id: number })`: Получает "кластер" записи, т.е. саму запись и информацию о ее каноническом статусе.
    - `get_record_similar_pairs_backup({ p_id: number, p_thr?: number, p_limit?: number, p_offset?: number })`: Находит семантически похожие записи с заданным порогом схожести (`p_thr`).

### Запись и обновление данных

Вся логика изменения данных сосредоточена в модальном окне `RecordModal`.

#### Редактирование кейса

- **Источник:** `src/components/RecordModal.tsx`
- **Описание:** Когда пользователь сохраняет изменения в полях "Тема", "Вопрос" или "Ответ", вызывается RPC-функция `edit_backup_content`.
- **RPC-функция:** `edit_backup_content({ p_id: number, p_new_content: string, p_metadata_patch: object })`
- **Параметры:**
    - `p_id`: ID редактируемой записи.
    - `p_new_content`: Новый, отформатированный контент записи.
    - `p_metadata_patch`: JSON-объект для обновления метаданных (например, `{"edited": true}`).

#### Установка канонической записи (дедупликация)

- **Источник:** `src/components/RecordModal.tsx`
- **Описание:** Когда пользователь нажимает "Сделать дублем" у похожей записи, вызывается RPC-функция `set_canonical_telegrambad_backup`.
- **RPC-функция:** `set_canonical_telegrambad_backup({ p_duplicate_id: number, p_canonical_id: number })`
- **Параметры:**
    - `p_duplicate_id`: ID записи, которая помечается как дубликат.
    - `p_canonical_id`: ID основной, канонической записи (та, что открыта в модальном окне).

#### Утверждение кейса ("Ок")

- **Источник:** `src/components/RecordModal.tsx`
- **Описание:** Нажатие на кнопку "Ок (в telegram)" инициирует отправку данных в Telegram.
- **RPC-функция:** `send_to_telegram_backup({ p_id: number, p_archive_source: boolean, ... })`
- **Параметры:**
    - `p_id`: ID отправляемой записи.
    - `p_archive_source`: `true`, если нужно архивировать исходную запись после отправки.

#### Отклонение кейса ("неОк")

- **Источник:** `src/components/RecordModal.tsx`
- **Описание:** Нажатие на кнопку "неОк (в архив)" архивирует текущую запись.
- **RPC-функция:** `archive_backup_record({ p_id: number, p_reason: string })`
- **Параметры:**
    - `p_id`: ID архивируемой записи.
    - `p_reason`: Причина архивации (в коде жестко задано значение `'manual'`).

## Интеграция с вебхуками

### Получение нового кейса

- **Описание:** Внешняя система (например, бот в Telegram) отправляет `POST` запрос на эндпоинт приложения для создания нового "необработанного" кейса. Эта логика, предположительно, находится на стороне сервера и напрямую вставляет данные в таблицу `telegrambad_backup`, из которой их потом читает `RecordsApp`.
- **Эндпоинт:** `https://<ваш-домен>/api/webhook` (предполагаемый)
- **Метод:** `POST`
- **Заголовки:**
  - `Content-Type: application/json`
  - `Authorization: Bearer <SECRET_TOKEN>`

### Тело запроса (Webhook Payload)

```json
{
  "source": "Telegram",
  "case_number": "TG-54321",
  "user_request": "Клиент жалуется, что не приходят уведомления на почту.",
  "user_conclusions": "Пользователь думает, что проблема в настройках его почтового ящика.",
  "metadata": {
    "telegram_user_id": "123456789",
    "chat_id": "987654321",
    "timestamp": "2023-10-27T10:00:00Z"
  }
}
```

### Обработка вебхука на сервере

1.  **Валидация** токена и тела запроса.
2.  **Форматирование данных** в единую строку `content` и/или запись `metadata`.
3.  **Запрос в Supabase:** Выполняется `INSERT` в таблицу `telegrambad_backup`.
    ```sql
    INSERT INTO telegrambad_backup (content, metadata) VALUES (...);
    ```
4.  **Ответ на вебхук** со статусом `201 Created` в случае успеха.
